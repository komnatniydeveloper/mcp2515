# Описание
Библиотека для взаимодействия с микросхемой MCP2515.
Реализует команды SPI интерфейса без каких-либо дополнительных абстракций.

Библиотека изначально проектировалась как платформонезависимая, в следствие чего пользователь сам должен реализовать некоторый код.
Например, функции передачи данных по SPI.
Такой подход значительно расширяет возможности применения библиотеки. Напрмер, в одном случае можно реализовать SPI на прерываниях, а в другом
использовать DMA.

# Документация
Все доступные пользователю функции библиотеки имеют комментарии, описывающие что они делают и как. Для генерирования документации можно использовать doxygen.
Кроме того, необходимо иметь представление о самой микросхеме MCP2515. Даташит на нее можно найти здесь: https://ww1.microchip.com/downloads/en/DeviceDoc/MCP2515-Family-Data-Sheet-DS20001801K.pdf

# Использование

Поддерживается как использование прерываний MCP2515, так и режим опроса. Следующий код показывает, что нужно сделать для работы
MCP2515 с использованием прерывания на выводе INT.

    include "mcp2515.h"
    include "mcp2515_regs.h"
    
    MCP2515_Interface_t mcp;
    
    void mcp2515_Reset (uint32_t reset)
    {
      // Управление сбросом MCP2515
      // Если reset = 0, то установить на выводе RESET микросхемы MCP2515 
      // высокий логический уровень,
      // в противном случае установить низкий логический уровень.
    }
    
    void mcp2515_ChipSelect (uint32_t select)
    {
      // SPI chip select
      // Если select = 0, то установить на выводе CS микросхемы MCP2515 
      // высокий логический уровень,
      // в противном случае установить низкий логический уровень
    }
    
    bool mcp2515_Transaction (size_t len)
    {
      // Функция вызывается, когда необходимо обменяться данными с MCP2515 по SPI.
      // Необходимо передать len байт из массива buffer переменной mcp и затем 
      // положить принятые данные обратно в тот же массив.
      // Если транзакция выполнена успешно, то вернуть true.
    }
    
    void mcp2515_Interrupt (void)
    {
      // Функция вызывается пользователем при возникновении прерывания MP2515.
      // Здесь нужно определить, по какой причине произошло прерывание, обработать 
      // прерывание (например, прочитать входящий фрейм), а затем сбросить прерывание
      
      uint8_t flags = *mcp2515_Read (&mcp2515, CANINTF, 1);
      
      if (flags & CANINTF_RX1IF_MASK)
      {
        // Прочитать фрейм из приемного буфера 1
      }
      
      if (flags & CANINTF_TX2IF_MASK)
      {
        // Прочитать фрейм из приемного буфера 2
      }
      
      ...
      
      mcp2515_BitModify(&mcp, CANINTF, flags, 0);
    }
    
    bool mcp2515_CheckInterrupt (void)
    {
      // Проверить состояние вывода INT MCP2515.
      // Если логический уровень на выводе низкий, значит произошло прерывание и необходимо вернуть true,
      // в противном случае вернуть false
    }
    
    int main (void)
    {
      // Устанавливаем обработчики событий
      mcp.onReset       = mcp2515_Reset;
      mcp.onChipSelect  = mcp2515_ChipSelect;
      mcp.onTransaction = mcp2515_Transaction;
      
      // Инициализируем библиотеку
      mcp2515_Initialize (&mcp, mcp2515_Interrupt);
      mcp2515_SoftReset (&mcp);
      // Тут нужно сделать задержку в несколько миллисекунд, чтобы MCP2515 заработала после сброса
      
      // Установить регистры MCP2515 в соответствии с требуемым режимом работы
      // Например, включить прерывания
      uint8_t intMask = CANINTE_TX2IE | CANINTE_TX1IE | CANINTE_TX0IE | CANINTE_RX1IE | CANINTE_RX0IE;
      mcp2515_Write (&mcp, CANINTE, &intMask, 1);
      
      // Бесконечный цикл обработки
      while (1)
      {
        if (mcp2515_CheckInterrupt ())
          mcp.onInterrupt ();
      }
    }
    
Для режима опроса достаточно в основном цикле программы использовать функции mcp2515_ReadStatus() и mcp2515_RxStatus().

# Поддерживаемое оборудование
Библиотека изначально проектировалась таким образом, чтобы исключить платформозависимый код. Пользователь сам должен его реализовать.

Список оборудования, на котором работа библиотеки была протестирована:
- stm32f411

Если вы имеете опыт использования библиотеки на оборудовании, которого нет в списке, просьба написать об этом автору.
